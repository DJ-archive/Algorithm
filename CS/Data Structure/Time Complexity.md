# 시간 복잡도
* 시간 복잡도는 서로 다른 알고리즘의 효율성을 비교할 때 사용
* 수행이 완료될 때까지 필요한 절차(단계)의 수로 측정

## 규칙
1. 입력값(n)은 항상 0보다 크다.

    입력값이 음수일 수는 없다. 그래서 복잡도는 항상 0보다 크다고 가정하고 계산을 해야한다.

2. 함수는 많은 입력값이 있을 때 더 많은 작업을 하게 됨

    더 많은 입력값이 주어지면 어떤 작업을 하는 데 필요한 계산이나 처리 시간이 길어짐

3. 시간 복잡도에서는 모든 상수를 삭제

    만약 어떤 알고리즘의 복잡도가  3n 이라면 3은 고려하지 않고 복잡도는 n  

4. 낮은 차수의 항들은 무시

    **n 이 무한으로 커진 경우를 가정**하고 비교하기 때문에 시간 복잡도에서는 낮은 차수의 항들은 무시

5. 시간 복잡도 함수가 log 함수를 포함할 경우 밑은 무시

    모든 로그는 서로 배수 관계
    > math.log(x)는 자연로그, but log의 밑이 무엇이든간에 log의 나눗셈 공식 등을 이용하여 밑을 서로 맞춰줄 수 있다. 

    로그의 밑은 무시하고 로그 ( logn ) 알고리즘이라고만 말하면 됨

6. 등호를 사용하여 표현

    2n 은 O(n)

    여기서  O(n)은  2n이 어떤 함수의 집합에 속한다는 의미를 가진다. 그렇기 때문에 아래와 같은 등호를 활용하여 이 관계를 수학적으로 쓸 수 있다.

    2n = O(n),  2n ∈ O(n)

## Big-O 복잡도
![빅오](https://user-images.githubusercontent.com/58822617/159616650-c0cbb5de-e40a-4a92-9d43-4ae5487373f3.png)
(출처: 바킹독의 실전 알고리즘)
* O(1): 시간 복잡도 - 상수 시간
    * **입력값의 크기와 관계없이**, 일정한 수의 단계(일정한 시간)만 수행

* O(n) : 선형 복잡도(linear complexity)
    * 입력값이 증가함에 따라 시간 또한 **같은 비율**로 증가
        * 연결리스트, 리스트


* O(log n) : 로그 복잡도(logarithmic complexity)
    * O(1) 다음으로 빠르고, O(n)보다 느림
    * 무언가를 반으로 나누거나 2를 곱한 경우에 자주 사용
        * 이진 검색 <br>
        cf) tradeoff 존재: 정렬되지 않은 배열에서는 사용 불가
    * 만약 for 반복문을 사용해서 무언가를 탐색하면서 반으로 나누거나 2를 곱할 때 복잡도는 밑이 2인 로그

* O(n^2) - 2차 복잡도(quadratic complexity)

    * 모든 요소를 서로 비교 (2중 for문)
        * 비효율적인 정렬 ex. 거품정렬
* O(n!)
    * 그래프 - 외판원 문제 

## Big-O 표기법
* 알고리즘의 효율성을 표시하는 표기법
* 빅 오 표기법을 사용하면 어떤 알고리즘을 다른 알고리즘과 비교해서 표현하는 것이 가능하다

![mceclip0](https://user-images.githubusercontent.com/58822617/159618276-225ec923-3c8b-43bc-ac82-ae73ac8ab99e.png)
<복잡도가  n 인 알고리즘에 빅 오 표기법을 적용한 그래프>
> **다른 알고리즘이 이 그래프의 어떤 위치에 있는지에 따라** 복잡도  n인 알고리즘과 다른 알고리즘의 복잡도를 비교할 수 있다.

- O (빅 오 복잡도) : 비교 대상인 그래프가 일치 혹은 아래에 있을 때. 비교 대상인 다른 알고리즘과 같거나 더 빠르다.
- θ (세타 복잡도) : 비교 대상인 그래프가 일치할 때. 비교 대상인 다른 알고리즘과 같다.
- Ω (빅 오메가 복잡도) : 비교 대상인 그래프가 일치 혹은 위에 있을 때. 비교 대상인 다른 알고리즘과 같거나 느리다.
- o (리틀 오 복잡도) : 비교 대상인 그래프가 아래에 있을 때. 비교 대상인 다른 알고리즘보다 더 빠르다.
- ω (리틀 오메가 복잡도) : 비교 대상인 그래프가 위에 있을 때. 비교 대상인 다른 알고리즘과 느리다.