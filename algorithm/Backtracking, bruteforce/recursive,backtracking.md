# 재귀 함수(Recursive Function)
* [**절차지향적 사고가 아닌, 귀납적 사고를 할줄 알아야 쉽게 풀 수 있다**](https://www.youtube.com/watch?v=8vDDJm5EewM)
* 하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘
* 재귀 함수의 종료 조건을 반드시 명시해야 한다.
    * 종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출되어, 최대 재귀 깊이 초과 메시지가 출력될 수 있다. (오류메시지와 함께 종료)
* 종료 조건을 포함한 재귀 함수 예제
* BOJ 하노이탑, 바킹독 참고

```python
def recursive_function(i):
  # 100번째 호출을 했을 때 종료되도록 종료 조건 명시 
  if i==100:
    return
  print(i,'번째 재귀함수에서',i+1,'번째 재귀함수를 호출합니다.')
  recursive_function(i+1)
  print(i,'번째 재귀함수를 종료합니다.')

recursive_function(1)
```
> 메서드는 stack 방식으로 호출된다! <br>
위의 코드 결과 참조


## 팩토리얼 구현 예제
```python
def factorial_recursive(n):
    if n<=1:
        return 1
    return n*factorial_recursive(n-1)

print(factorial_recursive(5))
```
## 최대공약수 계산 (유클리드 호제법)

> 유클리드 호제법 <br> 2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a>b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다.

 ```python
 n,m = map(int,input().split())

def GCD(n,m):
  if n%m==0:
    return m
  else:
    return GCD(m,n%m)

print(GCD(n,m))
```

* 재귀함수를 잘 활용하면, 복잡한 알고리즘을 간결하게 작성할 수 있다. 
* 하지만, 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수도 있고 **모든 재귀합수는 반복문을 이용하여 동일한 기능을 구현할 수 있기** 때문에 신중하게 사용해야 한다.
* 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓임
    * 따라서 스택을 사용해야할 때, 구현상 **스택 라이브러리 대신에 재귀 함수를 이용**하는 경우가 많음


# 백트래킹(Backtracking)
* 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘
* 백트래킹은 해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기(Backtrack)해 정답을 찾아가는 범용적인 알고리즘
* DFS는 백트래킹의 골격을 이루는 알고리즘
* 제약 충족 문제(Constraint Satisfaction Problem)에 유용
* 브루트포스와 유사하나, 한번 방문 후 가능성이 없는 경우에는 즉시 후보를 포기한다는 점에서 매번 같은 경로를 방문하는 브루트 포스보다는 훨씬 우아한 방식
> 제약 충족 문제: 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제 <br> ex. 수도쿠, 십자말 풀이, 8퀸 문제, 4색 문제 문자열 파싱, 조합 최적합 등