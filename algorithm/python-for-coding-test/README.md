
> 이것이 취업을 위한 코딩 테스트다 with Python <br> 
> 바킹독의 실전 알고리즘<br>

# Greedy
- **현재 상황에서 지금 당장 좋은 것만 고르는 방법**
- 그리디 해법은 그 **정당성 분석**이 중요
    - 지금 당장 손해를 보더라도, 나중 가서 이득인 경우가 있을 수 있는지 등 확인

  > 코딩 테스트 추천 전략
  코딩테스트에 그리디 유형 문제 생각보다 적게 나옴.
  그리디 100% 확신되는 것이 아니라면, 바로 풀이를 시작하기 보다는 다른 문제들을 먼저 보는 것도 방법이다.

  1. 거의 똑같은 문제를 풀어봤거나, 간단한 문제여서 나의 그리디 풀이를 100% 확신할 경우
  -> 짜서 제출해보고 틀리면 빠르게 손절
  2. 100% 확신은 없지만 맞는 것 같은 그리디 풀이를 찾았다.
  -> 일단은 넘어가고 다른 문제를 풀게 없거나 종료가 20~40분 남은 시점에 코딩 시작

* ex. 거스름돈(BOJ 11047) - 동전이 배수 관계라 가능

# DFS/BFS
- 탐색(Search): 많은 양의 데이터 중 원하는 데이터를 찾는 과정
- 대표적인 그래프 탐색 알고리즘: DFS, BFS

## DFS(Graph Traversals)
* 깊이 우선 탐색: 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
* 스택 자료구조(혹은 재귀함수)를 이용하며, 백트래킹으로 뛰어난 효용을 보일 수 있음
> 백트래킹의 골격

## BFS (Breadth-First-Search)
* 너비 우선 탐색: 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘
* 큐 자료구조 이용 (**재귀 이용x!!**)
* 그래프 최단경로 문제

# 다이나믹 프로그래밍
* 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
* 각 부분 문제들이 서로 영향을 미치며 '중복' 
  * 분할 정복과 구별되는 특징

> 문제를 해결하기 위한 점화식을 찾아낸 후, 점화식의 항을 밑에서부터 차례로 구해나가서 문제 해결

  1. 테이블 정의하기
  2. 점화식 찾기
  3. 초기값 정하기