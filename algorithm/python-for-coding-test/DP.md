# 다이나믹 프로그래밍

* 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
* 각 부분 문제들이 서로 영향을 미치며 '중복' 
  * 분할 정복과 구별되는 특징

> 문제를 해결하기 위한 점화식을 찾아낸 후, 점화식의 항을 밑에서부터 차례로 구해나가서 문제 해결

1. 테이블 정의하기
2. 점화식 찾기
3. 초기값 정하기


## 피보나치 수열
* 탑다운 다이나믹 프로그래밍 (python)
    * 재귀 
```python
# 99번째 피보나치 수 구하기

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0]*100

def fibo(x):
    # 호출되는 함수 확인해보기
    print('f('+str(x)+')',end=' ')
    # 종료조건
    if x==1 or x==2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x]!=0:
        return d[x]
    # 아직 계산되지 않은 문제라면 피보나치 점화식
    d[x]=fibo(x-1)+fibo(x-2)
    return d[x]

print(fibo(99))
```

* 보텀업 다이나믹 프로그래밍 (python)
  * 반복문

```python
d= [0]*100

# 전제조건
d[1]=1
d[2]=1
n = 99

# 피보나치 함수 반복문으로 구현
for i in range(3,n+1):
    d[i]=d[i-1]+d[i-2]

print(d[n])
```

## 접근 방법
* 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요
* 가장 먼저, 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토 후 다이나믹 프로그래밍 고려하기.
* 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그래도 사용될 수 있으면, 코드를 개선하는 방법 사용
* 일반적으로는, **기본 유형** 의 DP 문제가 출제되는 경우가 많다.
  * 점화식 떠올리기가 중요 (반복 연습 필요)

## 문제1. 개미 전사
```python
n = int(input())
wh = list(map(int,input().split()))

# 보텀업 방식
dp = [0]*100 # n 최댓값=100

dp[0]=wh[0]
dp[1]=max(dp[0],wh[1])

for i in range(2,n):
    dp[i] = max(dp[i-1],dp[i-2]+wh[i])

print(dp[n-1]) # 주의
```

## 문제2. 1로 만들기
* 그리디 1로 만들기 문제와 비교해서 차이 이해
    * 나누는 수가 여러 갈래이므로 그리디와 다름
